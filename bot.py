#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Bot T√≠n Hi·ªáu Binance Futures - Phi√™n b·∫£n 2.2
H·ªó tr·ª£ 5 chi·∫øn thu·∫≠t v·ªõi qu·∫£n l√Ω r·ªßi ro n√¢ng cao
"""

import pandas as pd
from datetime import datetime, timedelta
import time
import json
from concurrent.futures import ThreadPoolExecutor
from threading import Thread

# Load config
try:
    with open('config.json', 'r', encoding='utf-8') as f:
        config = json.load(f)
    print("‚úÖ ƒê√£ t·∫£i c·∫•u h√¨nh t·ª´ config.json")
except FileNotFoundError:
    print("‚ùå Kh√¥ng t√¨m th·∫•y config.json")
    exit(1)

# Import utilities
from utils.telegram import send_telegram
from utils.data_fetcher import get_klines_df
from utils.chart import create_chart
from utils.signal_manager import SignalManager
from utils.risk_manager import RiskManager
from utils.adaptive_system import AdaptiveSystem
from dashboard.app import bot_status, log, emit_update, socketio

# Import strategies
from strategies.ema_vwap_rsi import ema_vwap_rsi_strategy as strategy_ema_vwap
from strategies.supertrend_rsi import supertrend_rsi_strategy as strategy_supertrend_atr
from strategies.trend_momentum_volume import trend_momentum_volume_strategy as strategy_trend_momentum
from strategies.breakout_volume_sr import breakout_volume_sr_strategy as strategy_breakout_volume
from strategies.multi_timeframe import multi_timeframe_strategy as strategy_multi_timeframe

print(f"üöÄ Bot T√≠n Hi·ªáu Binance Futures (Qu·∫£n L√Ω R·ªßi Ro N√¢ng Cao) kh·ªüi ƒë·ªông l√∫c {datetime.now()}")

class TradingBot:
    def __init__(self):
        self.is_first_run = True
        self.signal_manager = SignalManager()
        self.risk_manager = RiskManager()
        self.adaptive_system = AdaptiveSystem()
        self.data_cache = {}
        self.last_cache_update = {}
        self.update_dashboard_config()
        self._update_managers_config()
        # Kh·ªüi ƒë·ªông dashboard trong thread ri√™ng
        Thread(target=self.run_dashboard, daemon=True).start()

    def _update_managers_config(self):
        """
        C·∫≠p nh·∫≠t c·∫•u h√¨nh cho c√°c manager
        """
        # C·∫≠p nh·∫≠t SignalManager
        signal_config = {
            'max_signals_per_hour': config['risk_management']['max_signals_per_hour'],
            'min_signal_gap_minutes': config['risk_management']['min_signal_gap_minutes']
        }
        self.signal_manager.update_config(signal_config)
        
        # C·∫≠p nh·∫≠t RiskManager
        risk_config = config['risk_management']
        self.risk_manager.max_risk_percent = risk_config.get('max_risk_percent', 1.0)
        self.risk_manager.max_daily_drawdown = risk_config.get('max_daily_drawdown', -5.0)
        self.risk_manager.max_drawdown = risk_config.get('max_drawdown', -15.0)
        self.risk_manager.max_daily_loss = risk_config.get('max_daily_loss', -3.0)
        self.risk_manager.max_consecutive_losses = risk_config.get('max_consecutive_losses', 5)
        
        print("‚úÖ ƒê√£ c·∫≠p nh·∫≠t c·∫•u h√¨nh qu·∫£n l√Ω r·ªßi ro")

    def run_dashboard(self):
        """
        Kh·ªüi ƒë·ªông Flask-SocketIO server
        """
        try:
            socketio.run(
                host='0.0.0.0',
                port=5000,
                debug=False,
                use_reloader=False
            )
        except Exception as e:
            print(f"‚ùå L·ªói kh·ªüi ƒë·ªông dashboard: {e}")
            log(f"‚ùå L·ªói dashboard: {e}")

    def update_dashboard_config(self):
        """
        C·∫≠p nh·∫≠t c·∫•u h√¨nh hi·ªán t·∫°i l√™n dashboard
        """
        bot_status['config'] = {
            'symbols': config['symbols'],
            'interval': config['interval'],
            'active_strategies': config['active_strategies'],
            'max_signals_per_hour': config['risk_management']['max_signals_per_hour'],
            'risk_management': config['risk_management']
        }
        log("‚úÖ C·∫•u h√¨nh ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t l√™n dashboard")
        emit_update()

    def get_cached_data(self, symbol, interval, limit=200):
        """Cache d·ªØ li·ªáu ƒë·ªÉ tr√°nh g·ªçi API li√™n t·ª•c"""
        cache_key = f"{symbol}_{interval}"
        now = datetime.now()
        if (cache_key in self.data_cache and 
            cache_key in self.last_cache_update and
            (now - self.last_cache_update[cache_key]).seconds < config['performance']['data_cache_minutes'] * 60):
            return self.data_cache[cache_key]
        df = get_klines_df(symbol, interval, limit)
        if df is not None:
            self.data_cache[cache_key] = df
            self.last_cache_update[cache_key] = now
        return df

    def execute_strategy(self, strategy_name, df, df_higher=None):
        """Th·ª±c thi m·ªôt chi·∫øn l∆∞·ª£c v·ªõi x√°c nh·∫≠n multi-timeframe"""
        # Strategy mapping
        strategy_map = {
            "EMA_VWAP": strategy_ema_vwap,
            "SUPERTREND_ATR": strategy_supertrend_atr,
            "TREND_MOMENTUM": strategy_trend_momentum,
            "BREAKOUT_VOLUME": strategy_breakout_volume,
            "MULTI_TIMEFRAME": strategy_multi_timeframe
        }
        
        if strategy_name not in strategy_map:
            print(f"‚ùå Chi·∫øn l∆∞·ª£c {strategy_name} kh√¥ng t·ªìn t·∫°i")
            return None
            
        try:
            strategy_func = strategy_map[strategy_name]
            signal = strategy_func(df, df_higher)
            
            if signal:
                signal['strategy'] = strategy_name
                signal['timestamp'] = datetime.now()
                return signal
        except Exception as e:
            print(f"‚ùå L·ªói th·ª±c thi chi·∫øn l∆∞·ª£c {strategy_name}: {e}")
            
        return None

    def analyze_market_conditions(self, df):
        """Ph√¢n t√≠ch ƒëi·ªÅu ki·ªán th·ªã tr∆∞·ªùng v·ªõi h·ªá th·ªëng adaptive"""
        try:
            # S·ª≠ d·ª•ng adaptive system ƒë·ªÉ ph√¢n t√≠ch
            market_conditions = self.adaptive_system.detect_market_regime(df)
            
            # Th√™m th√¥ng tin b·ªï sung
            market_conditions['current_price'] = df['close'].iloc[-1]
            market_conditions['atr'] = self.adaptive_system.calculate_volatility(df) * df['close'].iloc[-1]
            
            return market_conditions
        except Exception as e:
            print(f"‚ùå L·ªói ph√¢n t√≠ch ƒëi·ªÅu ki·ªán th·ªã tr∆∞·ªùng: {e}")
            return {'regime': 'UNKNOWN', 'volatility': 0.02, 'volume_ratio': 1.0}
    
    def get_adaptive_strategies(self, market_conditions):
        """
        Tr·∫£ v·ªÅ danh s√°ch chi·∫øn l∆∞·ª£c ph√π h·ª£p v·ªõi ƒëi·ªÅu ki·ªán th·ªã tr∆∞·ªùng hi·ªán t·∫°i
        """
        # S·ª≠ d·ª•ng adaptive system ƒë·ªÉ ch·ªçn chi·∫øn l∆∞·ª£c
        strategies = self.adaptive_system.get_adaptive_strategies(market_conditions)
        
        # Map strategy names to actual strategy functions
        strategy_mapping = {
            'EMA_VWAP': 'EMA_VWAP',
            'SUPERTREND_ATR': 'SUPERTREND_ATR', 
            'TREND_MOMENTUM': 'TREND_MOMENTUM',
            'BREAKOUT_VOLUME': 'BREAKOUT_VOLUME',
            'MULTI_TIMEFRAME': 'MULTI_TIMEFRAME'
        }
        
        # Convert to actual strategy names
        active_strategies = []
        for strategy in strategies:
            if strategy in strategy_mapping:
                active_strategies.append(strategy_mapping[strategy])
        
        return active_strategies

    def filter_and_rank_signals(self, signals, market_conditions):
        """L·ªçc v√† x·∫øp h·∫°ng t√≠n hi·ªáu v·ªõi adaptive system"""
        if not signals:
            return []
            
        for signal in signals:
            # T√≠nh ƒëi·ªÉm tin c·∫≠y d·ª±a tr√™n ƒëi·ªÅu ki·ªán th·ªã tr∆∞·ªùng
            confidence = signal.get('confidence', 0.5)
            
            # ƒêi·ªÅu ch·ªânh theo market regime
            regime = market_conditions.get('regime', 'UNKNOWN')
            if regime in ['BULLISH_TRENDING', 'BEARISH_TRENDING']:
                if (regime == 'BULLISH_TRENDING' and signal['side'] == 'BUY') or \
                   (regime == 'BEARISH_TRENDING' and signal['side'] == 'SELL'):
                    confidence *= 1.3  # TƒÉng confidence trong trending markets
                else:
                    confidence *= 0.7  # Gi·∫£m confidence cho signals ng∆∞·ª£c trend
            elif regime == 'VOLATILE':
                confidence *= 0.9  # Gi·∫£m confidence trong volatile markets
            elif regime in ['SIDEWAYS', 'CONSOLIDATION']:
                confidence *= 0.8
                
            # ƒêi·ªÅu ch·ªânh theo volume
            volume_ratio = market_conditions.get('volume_ratio', 1.0)
            if volume_ratio > 1.5:
                confidence *= 1.1
            elif volume_ratio < 0.5:
                confidence *= 0.9
                
            # ƒêi·ªÅu ch·ªânh theo volatility
            volatility = market_conditions.get('volatility', 0.02)
            if volatility > 0.05:
                confidence *= 0.9  # Gi·∫£m confidence trong high volatility
            elif volatility < 0.02:
                confidence *= 1.05  # TƒÉng confidence trong low volatility
                
            signal['final_confidence'] = min(confidence, 1.0)
            
        # S·∫Øp x·∫øp theo ƒë·ªô tin c·∫≠y
        signals.sort(key=lambda x: x['final_confidence'], reverse=True)
        return [s for s in signals if s['final_confidence'] >= 0.6]

    def run_analysis_cycle(self):
        """M·ªôt chu k·ª≥ ph√¢n t√≠ch ho√†n ch·ªânh cho t·∫•t c·∫£ c√°c c·∫∑p ti·ªÅn"""
        interval = config['interval']

        for symbol in config['symbols']:
            print(f"\nüîç ƒêang ph√¢n t√≠ch {symbol}...")

            try:
                # L·∫•y d·ªØ li·ªáu
                df_main = self.get_cached_data(symbol, interval, 200)
                df_higher = None
                if config['risk_management']['enable_multi_timeframe']:
                    higher_interval = "15m" if interval == "5m" else "1h"
                    df_higher = self.get_cached_data(symbol, higher_interval, 100)

                if df_main is None or len(df_main) < 50:
                    print(f"‚ùå {symbol}: Kh√¥ng ƒë·ªß d·ªØ li·ªáu")
                    continue

                # Ph√¢n t√≠ch ƒëi·ªÅu ki·ªán th·ªã tr∆∞·ªùng v·ªõi adaptive system
                market_conditions = self.analyze_market_conditions(df_main)
                print(f"üìä {symbol}: {market_conditions.get('regime', 'UNKNOWN')}, Vol: {market_conditions.get('volatility', 0):.3f}, VolRatio: {market_conditions.get('volume_ratio', 1.0):.2f}")

                # L·∫•y adaptive strategies
                adaptive_strategies = self.get_adaptive_strategies(market_conditions)
                print(f"üéØ Adaptive strategies cho {symbol}: {adaptive_strategies}")

                # Ch·∫°y chi·∫øn l∆∞·ª£c adaptive
                signals = []
                max_workers = len(adaptive_strategies)
                
                if config['performance']['parallel_strategy_execution']:
                    with ThreadPoolExecutor(max_workers=max_workers) as executor:
                        futures = [
                            executor.submit(self.execute_strategy, strategy, df_main, df_higher)
                            for strategy in adaptive_strategies
                        ]
                        for future in futures:
                            result = future.result()
                            if result:
                                signals.append(result)
                else:
                    for strategy in adaptive_strategies:
                        result = self.execute_strategy(strategy, df_main, df_higher)
                        if result:
                            signals.append(result)

                # L·ªçc t√≠n hi·ªáu
                qualified_signals = self.filter_and_rank_signals(signals, market_conditions)

                # G·ª≠i t√≠n hi·ªáu t·ªët nh·∫•t
                for signal in qualified_signals:
                    # ‚úÖ B·ªè qua t√≠n hi·ªáu ·ªü l·∫ßn ch·∫°y ƒë·∫ßu ti√™n
                    if self.is_first_run:
                        print("üü° L·∫ßn ch·∫°y ƒë·∫ßu ti√™n - Kh√¥ng g·ª≠i t√≠n hi·ªáu c≈©")
                        self.is_first_run = False
                        break

                    # Th√™m th√¥ng tin symbol v√†o signal
                    signal['symbol'] = symbol
                    
                    # Ki·ªÉm tra qu·∫£n l√Ω r·ªßi ro
                    if not self.risk_manager.can_send_signal(signal):
                        print(f"‚ö†Ô∏è T√≠n hi·ªáu {signal['strategy']} b·ªã t·ª´ ch·ªëi b·ªüi RiskManager")
                        continue
                        
                    # Ki·ªÉm tra qu·∫£n l√Ω t√≠n hi·ªáu
                    if not self.signal_manager.should_send_signal(signal):
                        print(f"‚ö†Ô∏è T√≠n hi·ªáu {signal['strategy']} b·ªã t·ª´ ch·ªëi b·ªüi SignalManager")
                        continue
                        
                    # G·ª≠i t√≠n hi·ªáu
                    self.send_trading_signal(signal, market_conditions, df_main, symbol)
                    
                    # Ghi l·∫°i t√≠n hi·ªáu
                    self.signal_manager.record_signal(signal)
                    
                    # C·∫≠p nh·∫≠t dashboard
                    self._update_dashboard_stats()
                    
                    break  # Ch·ªâ g·ª≠i 1 t√≠n hi·ªáu m·ªói chu k·ª≥

            except Exception as e:
                error_msg = f"üî¥ L·ªói ph√¢n t√≠ch {symbol}: {str(e)}"
                print(error_msg)
                send_telegram(error_msg)

    def _update_dashboard_stats(self):
        """
        C·∫≠p nh·∫≠t th·ªëng k√™ l√™n dashboard
        """
        try:
            # C·∫≠p nh·∫≠t th·ªëng k√™ t√≠n hi·ªáu
            signal_stats = self.signal_manager.get_signal_statistics()
            risk_summary = self.risk_manager.get_risk_summary()
            
            bot_status['signal_stats'] = signal_stats
            bot_status['risk_summary'] = risk_summary
            bot_status['last_update'] = datetime.now().isoformat()
            
            emit_update()
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói c·∫≠p nh·∫≠t dashboard: {e}")

    def send_trading_signal(self, signal, market_conditions, df, symbol):
        """G·ª≠i t√≠n hi·ªáu giao d·ªãch v·ªõi adaptive system"""
        try:
            # T√≠nh to√°n adaptive SL/TP v√† R/R ratio
            atr = market_conditions.get('atr', 0.02 * signal['entry'])
            adaptive_sl, adaptive_tp = self.adaptive_system.calculate_adaptive_sl_tp(
                signal['entry'], signal['side'], market_conditions, atr
            )
            
            # T√≠nh adaptive R/R ratio
            adaptive_rr_ratio = self.adaptive_system.calculate_adaptive_rr_ratio(market_conditions)
            
            # C·∫≠p nh·∫≠t signal v·ªõi adaptive values
            signal['sl'] = adaptive_sl
            signal['tp'] = adaptive_tp
            signal['rr_ratio'] = adaptive_rr_ratio
            
            chart_path = f"chart_{signal['strategy'].lower()}_{symbol}.png"
            create_chart(df, symbol, signal['side'], 
                        signal['entry'], signal['sl'], signal['tp'], chart_path)

            # T√≠nh to√°n risk/reward v·ªõi adaptive values
            if signal['side'] == 'BUY':
                risk = (signal['entry'] - signal['sl']) / signal['entry'] * 100
                reward = (signal['tp'] - signal['entry']) / signal['entry'] * 100
            else:
                risk = (signal['sl'] - signal['entry']) / signal['entry'] * 100
                reward = (signal['entry'] - signal['tp']) / signal['entry'] * 100
            rr_ratio = reward / risk if risk > 0 else 0

            # L·∫•y market insights
            market_insights = self.adaptive_system.get_market_insights(market_conditions)
            
            # L·∫•y th√¥ng tin qu·∫£n l√Ω r·ªßi ro
            risk_summary = self.risk_manager.get_risk_summary()
            signal_stats = self.signal_manager.get_signal_statistics()

            # T·∫°o message v·ªõi adaptive information
            message = f"""üîî **T√çN HI·ªÜU GIAO D·ªäCH ADAPTIVE** üîî
üìå **Th√¥ng tin c∆° b·∫£n:**
‚Ä¢ C·∫∑p: *{symbol}*
‚Ä¢ Chi·∫øn l∆∞·ª£c: *{signal['strategy']}*
‚Ä¢ H∆∞·ªõng: *{signal['side']}* 
‚Ä¢ ƒê·ªô tin c·∫≠y: {signal['final_confidence']:.1%} ‚≠ê

üí∞ **Chi ti·∫øt l·ªánh (Adaptive):**
‚Ä¢ Gi√° v√†o: `{signal['entry']:.8f}`
‚Ä¢ Stop-Loss: `{signal['sl']:.8f}` (-{risk:.2f}%)
‚Ä¢ Take-Profit: `{signal['tp']:.8f}` (+{reward:.2f}%)
‚Ä¢ R/R Ratio: 1:{rr_ratio:.2f}

üìä **ƒêi·ªÅu ki·ªán th·ªã tr∆∞·ªùng (Adaptive):**
‚Ä¢ Market Regime: {market_conditions.get('regime', 'UNKNOWN')}
‚Ä¢ Volatility: {market_conditions.get('volatility', 0):.3f} ({market_insights['volatility_regime']})
‚Ä¢ Volume: {market_conditions.get('volume_ratio', 1.0):.2f}x b√¨nh th∆∞·ªùng
‚Ä¢ Risk Level: {market_insights['risk_level']}

üéØ **Adaptive Insights:**
‚Ä¢ Recommended R/R: 1:{adaptive_rr_ratio:.2f}
‚Ä¢ Market Regime: {market_insights['market_regime']}
‚Ä¢ Optimal Strategies: {', '.join(market_insights['strategy_recommendations'])}

üõ°Ô∏è **Qu·∫£n l√Ω r·ªßi ro:**
‚Ä¢ Win Rate: {risk_summary['win_rate']:.1f}%
‚Ä¢ Chu·ªói th·∫Øng: {risk_summary['win_streak']}
‚Ä¢ Drawdown: {risk_summary['current_drawdown']:.2f}%
‚Ä¢ T·ªïng l·ªánh: {risk_summary['total_trades']}

üìà **Th·ªëng k√™ t√≠n hi·ªáu:**
‚Ä¢ T√≠n hi·ªáu/gi·ªù: {signal_stats['signals_last_hour']}/{signal_stats['max_signals_per_hour']}
‚Ä¢ T√≠n hi·ªáu/ng√†y: {signal_stats['signals_last_day']}

‚è∞ **Th·ªùi gian:** {datetime.now().strftime('%H:%M:%S')}"""

            # G·ª≠i t√≠n hi·ªáu
            send_telegram(message, chart_path)
            
            # C·∫≠p nh·∫≠t performance history
            self.adaptive_system.update_performance_history({
                'strategy': signal['strategy'],
                'market_regime': market_conditions.get('regime'),
                'rr_ratio': rr_ratio,
                'volatility': market_conditions.get('volatility'),
                'confidence': signal['final_confidence']
            })
            
            # Log
            log_msg = f"‚úÖ ƒê√£ g·ª≠i t√≠n hi·ªáu adaptive {signal['strategy']} cho {symbol} (Confidence: {signal['final_confidence']:.1%}, R/R: 1:{rr_ratio:.2f})"
            print(log_msg)
            log(log_msg)

        except Exception as e:
            error_msg = f"‚ùå L·ªói g·ª≠i t√≠n hi·ªáu {symbol}: {str(e)}"
            print(error_msg)
            send_telegram(error_msg)

    def responsive_sleep(self, total_seconds):
        """Ng·ªß th√¥ng minh v·ªõi kh·∫£ nƒÉng d·ª´ng"""
        interval = 5  # Ki·ªÉm tra m·ªói 5 gi√¢y
        for _ in range(total_seconds // interval):
            time.sleep(interval)
        time.sleep(total_seconds % interval)

    def run_bot(self):
        """Ch·∫°y bot ch√≠nh"""
        print("üöÄ Bot ƒëang ch·∫°y...")
        print(f"üìä C·∫∑p ti·ªÅn: {', '.join(config['symbols'])}")
        print(f"‚è∞ Interval: {config['interval']}")
        print(f"üéØ Chi·∫øn l∆∞·ª£c: {', '.join(config['active_strategies'])}")
        print(f"üõ°Ô∏è Qu·∫£n l√Ω r·ªßi ro: {config['risk_management']['max_signals_per_hour']} t√≠n hi·ªáu/gi·ªù")
        
        while True:
            try:
                self.run_analysis_cycle()
                self.responsive_sleep(300)  # 5 ph√∫t
            except KeyboardInterrupt:
                print("\nüõë Bot ƒë√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng")
                break
            except Exception as e:
                error_msg = f"‚ùå L·ªói ch√≠nh: {str(e)}"
                print(error_msg)
                send_telegram(error_msg)
                time.sleep(60)  # Ch·ªù 1 ph√∫t tr∆∞·ªõc khi th·ª≠ l·∫°i

if __name__ == "__main__":
    bot = TradingBot()
    bot.run_bot()